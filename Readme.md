# Design

I implemented the sample exercise using an event-driven system for flexibility and decoupling
 from any existing application code. There is a central subscriber `OviaIncentiveSubscriber` that
  acts as the traffic control for any of the `OviaEvents` that are dispatched in the system. 

There are four main concepts.
- `Events` representing some change in another system
- `Incentives` representing an incentive program running
- `Evaluators` contain the logic to determine if an incentives requirements are met 
- `Rewards` representing the reward(s) that would get generated by successfully completing an incentive program. 

My goal was to have a flexible enough system that the three main concepts 
 `Events`, `Incentives (with Evaluators)`, and `Rewards` are independent enough to not constrain
  scaling, technology  & implementation solutions. 

For example:
- If there's an `Event` that dispatches and does not need to provide the `Incentive` state back
 to the user, it could go into a message queue. A background worker could then process the message
  queue and dispatch them to the `OviaIncentiveSubscriber`. 
- `Rewards` processing can be independent of the `Incentives`. Background processing could help
 with state reconciliation, persistence and reporting.
- The incentive system could act as a microservice to the main Ovia app receiving and processing
 inbound `Events`. 

# Notes
- I tried to leave notes in the code when assumptions were made.  In particular, I assumed
 there is a way to get user `Incentive` eligibility and state. This incentive system, the user
  applications, and a system for assigning users to incentives
   would all need this data.  
- The duplication in the `on$SOMETHINGEvent` classes in the `OviaIncentiveSubscriber` should be
 considered code debt to be refactored.
- There are two tests are in the `tests/` folder
    - `BirthEventTests` to check that the key components were testable
    - `DataLoggedIncentiveEvaluatorTests` to verify the logic in `DataLoggedIncentiveEvaluator` given some test cases
- The system could be built with any mature framework that has events, messages queues and background worker capabilities. 


# Exercise Feedback

I spent ~8 hours over 3 days on the exercise.
- Upfront system design thinking / sketching (1 hour)
- Scaffolding initial design with Laravel (.75 hour)
- Finding / understanding the Symfony components for events, listeners, subscribers (1 hour)
- Coding and Tests (~4.5 hour)
- Readme.md and code documentation review (~.75 hour)

My initial thought was to scaffold the app out in Laravel due to my familiarity with it (used as
 one of the frameworks in my current position) and Laravel's ability to quickly provide the
  components my design needed (events, listeners, subscribers, queues, workers).   For the
   purposes of the exercise, I only needed events and my implementation was
    much more clear without the framework, hence the pivot. 

It was an interesting exercise to work through. 