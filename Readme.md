# Design

I implemented the sample excersise using an event-driven system for flexibility and decoupling from any exsiting application code.    There is a central subsriber `OviaIncentiveSubscriber` that acts as the traffic control for any of the `OviaEvents` that are dispatched in the system. 

The code is organized around four main concepts.
- `Events` representing some change in another system
- `Incentives` representing an incentive program running
- `Evaluators` contain the logic to determine if an incentives requirements are met 
- `Rewards` representing the reward(s) that would get generated by successfully completing an incentive program. 

My goal was to have a flexible enough system that the three main operations:
 `Events`, `Incentives (with Evaluators)`, and `Rewards` are indepedent enough that scaling, technology solutions & implementations would not be constrained. 

Some examples:
- If there's an `Event` that dispatches and does not need to provide the `Incentive` state back to the user, it could be put into a message queue and then a background worker could process them out of the message queue and dispatch them to the `Subscriber`. 
- `Rewards` processing can be indepent of the `Incentives`.  There is some work around state reconicialltion, persistence and reporting to still design; another area where background processing would be benefical.
- The incentive system could act as a microservice to the main Ovia app receiving and processing inbound `Event`. 

# System Notes
- I tried to leave notes in the code when assumptions where made.  In particular, I assumed that a lookup for what `Incentives` a user is eligible for and the state of those incentives exsisted.  This system system, the customer applications and a system for assinging users to incentives would all need to interact with this lookup system. 
- The duplication in `on$SOMETHINGEvent` classes in the `OviaIncentiveSubscriber` should be considered code debt that to be refactored.
- There are two tests are in the `tests/` folder
    - `BirthEventTests` to check that the key components were testable
    - `DataLoggedIncentiveEvaluatorTests` to verify the logic in `DataLoggedIncentiveEvaluator` given some test cases. 
- The system could be built with any mature framework that has events, messages queues and background worker capabilities. 


# Exercise Feedback

I spent ~8 hours over 3 days on the exercise.
- Upfront system design thinking / sketching (1 hour)
- Scaffolding initial design with Laravel (.75 hour)
- Finding / understading the Symfony components for events, listeners, subscribers (1 hour)
- Coding and Tests (~4.5 hour)
- Readme.md and code documenation review (~.75 hour)

My initial thought was to scaffold the app out in Laravel due to my familiarity with it (used as one of the frameworks in my current position) and Laravel's ability to quickly provide the components my design needed (events, listeners, subscribers, queues, workers).   I pivotted off of Laravel when realizing that for the purposes of this exercise I only needed a way to handle events and I wanted to remove any framework's opinions from the code samples. 

It was an interesting exercise to work through. 